/* 
 * Titan API
 *
 * The ultimate, language agnostic, container based job processing framework.
 *
 * OpenAPI spec version: 0.4.6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package titan

import (
	"strings"
	"fmt"
	"errors"
	"net/url"
	"time"
"os"
"io/ioutil"
"encoding/json"
)

type JobsApi struct {
	Configuration Configuration
}

func NewJobsApi() *JobsApi {
	configuration := NewConfiguration()
	return &JobsApi{
		Configuration: *configuration,
	}
}

func NewJobsApiWithBasePath(basePath string) *JobsApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &JobsApi{
		Configuration: *configuration,
	}
}

/**
 * Get job list by group name.
 * This will list jobs for a particular group.
 *
 * @param name Name of group for this set of jobs.
 * @param createdAfter Will return jobs created after this time. In RFC3339 format.
 * @param n Number of jobs to return.
 * @return *JobsWrapper
 */
func (a JobsApi) GroupsNameJobsGet(name string, createdAfter time.Time, n int32) (*JobsWrapper, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobsWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsGet")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("createdAfter", a.Configuration.APIClient.ParameterToString(createdAfter, ""))
			queryParams.Add("n", a.Configuration.APIClient.ParameterToString(n, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JobsWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Cancel a job.
 * Cancels a job in delayed, queued or running status. The worker may continue to run a running job. reason is set to &#x60;client_request&#x60;. The job&#39;s completed_at field is set to the current time on the jobserver.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdCancelPost(name string, id string) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/cancel"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdCancelPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdCancelPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete the job.
 * Delete only succeeds if job status is one of &#x60;succeeded | failed | cancelled&#x60;. Cancel a job if it is another state and needs to be deleted.  All information about the job, including the log, is irretrievably lost when this is invoked. 
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @return void
 */
func (a JobsApi) GroupsNameJobsIdDelete(name string, id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdDelete")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdDelete")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Mark job as failed.
 * Job is marked as failed if it was in a valid state. Job&#39;s &#x60;finished_at&#x60; time is initialized.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @param body 
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdErrorPost(name string, id string, body Complete) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/error"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdErrorPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdErrorPost")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'body' when calling JobsApi->GroupsNameJobsIdErrorPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &body

	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Gets job by id
 * Gets a job by id.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdGet(name string, id string) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdGet")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdGet")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Get the log of a completed job.
 * Retrieves the log from log storage.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @return *string
 */
func (a JobsApi) GroupsNameJobsIdLogGet(name string, id string) (*string, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/log"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(string), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdLogGet")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(string), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdLogGet")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"text/plain",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(string)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Send in a log for storage.
 * Logs are sent after a job completes since they may be very large and the runner can process the next job.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @param log Output log for the job. Content-Type must be \&quot;text/plain; charset&#x3D;utf-8\&quot;.
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdLogPost(name string, id string, log *os.File) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/log"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdLogPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdLogPost")
	}
	// verify the required parameter 'log' is set
	if &log == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'log' when calling JobsApi->GroupsNameJobsIdLogPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	fbs, _ := ioutil.ReadAll(file)
	fileBytes = fbs
	fileName = file.Name()

	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retry a job.
 * \&quot;The /retry endpoint can be used to force a retry of jobs with status succeeded or cancelled. It can also be used to retry jobs that in the failed state, but whose max_retries field is 0. The retried job will continue to have max_retries &#x3D; 0.\&quot; 
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdRetryPost(name string, id string) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/retry"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdRetryPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdRetryPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Mark job as started, ie: status &#x3D; &#39;running&#39;
 * Job status is changed to &#39;running&#39; if it was in a valid state before. Job&#39;s &#x60;started_at&#x60; time is initialized.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @param body 
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdStartPost(name string, id string, body Start) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/start"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdStartPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdStartPost")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'body' when calling JobsApi->GroupsNameJobsIdStartPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &body

	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Mark job as succeeded.
 * Job status is changed to succeeded if it was in a valid state before. Job&#39;s &#x60;completed_at&#x60; time is initialized.
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @param body 
 * @return *JobWrapper
 */
func (a JobsApi) GroupsNameJobsIdSuccessPost(name string, id string, body Complete) (*JobWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/success"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdSuccessPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdSuccessPost")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return new(JobWrapper), nil, errors.New("Missing required parameter 'body' when calling JobsApi->GroupsNameJobsIdSuccessPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &body

	var successPayload = new(JobWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Extend job timeout.
 * Consumers can sometimes take a while to run the task after accepting it.  An example is when the runner does not have the docker image locally, it can spend a significant time downloading the image. If the timeout is small, the job may never get to run, or run but not be accepted by Titan. Consumers can touch the job before it times out. Titan will reset the timeout, giving the consumer another timeout seconds to run the job. Touch is only valid while the job is in a running state. If touch fails, the runner may stop running the job. 
 *
 * @param name Name of group for this set of jobs.
 * @param id Job id
 * @return void
 */
func (a JobsApi) GroupsNameJobsIdTouchPost(name string, id string) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs/{id}/touch"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsIdTouchPost")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling JobsApi->GroupsNameJobsIdTouchPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Enqueue Job
 * Enqueues job(s). If any of the jobs is invalid, none of the jobs are enqueued. 
 *
 * @param name name of the group.
 * @param body Array of jobs to post.
 * @return *JobsWrapper
 */
func (a JobsApi) GroupsNameJobsPost(name string, body NewJobsWrapper) (*JobsWrapper, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/groups/{name}/jobs"
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	// verify the required parameter 'name' is set
	if &name == nil {
		return new(JobsWrapper), nil, errors.New("Missing required parameter 'name' when calling JobsApi->GroupsNameJobsPost")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return new(JobsWrapper), nil, errors.New("Missing required parameter 'body' when calling JobsApi->GroupsNameJobsPost")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &body

	var successPayload = new(JobsWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Get next job.
 * Gets the next job in the queue, ready for processing. Titan may return &lt;&#x3D;n jobs. Consumers should start processing jobs in order. Each returned job is set to &#x60;status&#x60; \&quot;running\&quot; and &#x60;started_at&#x60; is set to the current time. No other consumer can retrieve this job.
 *
 * @param n Number of jobs to return.
 * @return *JobsWrapper
 */
func (a JobsApi) JobsGet(n int32) (*JobsWrapper, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/jobs"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("n", a.Configuration.APIClient.ParameterToString(n, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JobsWrapper)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

